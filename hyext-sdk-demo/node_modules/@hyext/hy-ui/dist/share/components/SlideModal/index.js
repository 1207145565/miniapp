function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

import React from 'react';
import { View, TouchableOpacity, StyleSheet, Animated } from 'react-native';
import { Modal } from '../Modal';
import { SlideAnimated } from '../../common/animations';
import variables from '../../common/styles/variables';
export var slideModalStyles = StyleSheet.create({
  container: {
    position: 'absolute',
    top: 0,
    left: 0,
    bottom: 0,
    right: 0,
    flexDirection: 'row',
    alignItems: 'flex-start',
    justifyContent: 'center',
    overflow: 'hidden'
  },
  backdrop: {
    position: 'absolute',
    top: 0,
    left: 0,
    bottom: 0,
    right: 0,
    backgroundColor: variables.hyFillBackdrop
  },
  content: {
    position: 'absolute',
    overflow: 'hidden'
  }
});
export var SlideModal =
/*#__PURE__*/
function (_Modal) {
  _inheritsLoose(SlideModal, _Modal);

  function SlideModal(props) {
    var _this;

    _this = _Modal.call(this, props) || this;

    _this.handleLayout = function (e) {
      var _this$state = _this.state,
          directionType = _this$state.directionType,
          direction = _this$state.direction;
      var _e$nativeEvent$layout = e.nativeEvent.layout,
          width = _e$nativeEvent$layout.width,
          height = _e$nativeEvent$layout.height;
      var ret = [];
      directionType.forEach(function (directionTypeItem) {
        if (directionTypeItem === 'vertical') {
          ret.push({
            size: direction.indexOf('up') !== -1 ? height : -height,
            directionTypeItem: directionTypeItem
          });
        }

        if (directionTypeItem === 'horizontal') {
          ret.push({
            size: direction.indexOf('right') !== -1 ? -width : width,
            directionTypeItem: directionTypeItem
          });
        }
      });

      _this.animated.reset(ret);
    };

    return _this;
  } // 重写 Modal 父类 init 方法


  var _proto = SlideModal.prototype;

  _proto.init = function init(props, syncTag) {
    var directions = [['up'], ['up', 'left'], ['up', 'right'], ['down'], ['down', 'left'], ['down', 'right'], ['left'], ['right']];
    var direction = typeof props.direction === 'string' ? [props.direction] : props.direction;
    var propsDirectionValid = directions.some(function (directionItem) {
      var str1 = directionItem.join();
      var str2 = directionItem.reverse().join();
      var str3 = direction.join();

      if (str3 === str1 || str3 === str2) {
        return true;
      }
    });

    if (!propsDirectionValid) {
      throw new TypeError("direction \u53C2\u6570 " + props.direction + " \u4E3A\u65E0\u6548\u503C");
    }

    var directionType = [];

    if (direction.indexOf('up') !== -1 || direction.indexOf('down') !== -1) {
      directionType.push('vertical');
    }

    if (direction.indexOf('left') !== -1 || direction.indexOf('right') !== -1) {
      directionType.push('horizontal');
    }

    var align;

    if (direction.length === 1) {
      if (directionType.indexOf('vertical') !== -1) {
        align = props.align === 'left' || props.align === 'right' ? props.align : 'right';
      } else {
        align = props.align === 'up' || props.align === 'down' ? props.align : 'down';
      }
    }

    var directionWithAlign = [];

    if (direction.length === 2) {
      directionWithAlign = direction;
    } else {
      directionWithAlign = [].concat(direction, [align]);
    }

    var offsetY = typeof props.offsetY === 'number' ? props.offsetY : props.viewportHeight;
    var data = {
      directionType: directionType,
      direction: direction,
      align: align,
      directionWithAlign: directionWithAlign,
      offsetY: offsetY
    };
    this.animated = new SlideAnimated({
      // duration: 1000
      directionType: data.directionType
    });

    if (syncTag) {
      this.state = _objectSpread({}, this.state, {}, data);
    } else {
      this.setState(_objectSpread({}, this.state, {}, data));
    }
  };

  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.direction !== this.props.direction || nextProps.align !== this.props.align || nextProps.offsetX !== this.props.offsetX || nextProps.offsetY !== this.props.offsetY || nextProps.viewportWidth !== this.props.viewportWidth || nextProps.viewportHeight !== this.props.viewportHeight) {
      this.init(nextProps, false);
    }
  };

  _proto.open = function open(c) {
    return Modal.prototype.open.call(this, c);
  };

  _proto.getRects = function getRects() {
    var _this$props = this.props,
        offsetX = _this$props.offsetX,
        viewportWidth = _this$props.viewportWidth,
        viewportHeight = _this$props.viewportHeight;
    var _this$state2 = this.state,
        directionWithAlign = _this$state2.directionWithAlign,
        offsetY = _this$state2.offsetY;
    var defaultRect = {
      top: null,
      bottom: null,
      left: null,
      right: null
    };

    var contentContainerRect = _objectSpread({}, defaultRect);

    var contentRect = _objectSpread({}, defaultRect);

    var contentClockwise2Rect = _objectSpread({
      backgroundColor: 'red'
    }, defaultRect);

    var contentClockwise1Rect = _objectSpread({
      backgroundColor: 'blue'
    }, defaultRect);

    var contentClockwise3Rect = _objectSpread({
      backgroundColor: 'green'
    }, defaultRect);

    if (directionWithAlign.indexOf('up') !== -1) {
      contentContainerRect.top = 0;
      contentContainerRect.bottom = viewportHeight - offsetY;
      contentClockwise2Rect.top = offsetY;
      contentClockwise2Rect.bottom = 0;
      contentClockwise1Rect.left = offsetX;
      contentClockwise1Rect.right = 0;
      contentClockwise3Rect.left = 0;
      contentClockwise3Rect.right = viewportWidth - offsetX;
      contentRect.bottom = 0;
    }

    if (directionWithAlign.indexOf('down') !== -1) {
      contentContainerRect.top = offsetY;
      contentContainerRect.bottom = 0;
      contentClockwise2Rect.top = 0;
      contentClockwise2Rect.bottom = viewportHeight - offsetY;
      contentClockwise1Rect.left = 0;
      contentClockwise1Rect.right = viewportWidth - offsetX;
      contentClockwise3Rect.left = offsetX;
      contentClockwise3Rect.right = 0;
      contentRect.top = 0;
    }

    if (directionWithAlign.indexOf('right') !== -1) {
      contentContainerRect.left = offsetX;
      contentContainerRect.right = 0;
      contentClockwise2Rect.left = 0;
      contentClockwise2Rect.right = viewportWidth - offsetX;
      contentClockwise1Rect.top = offsetY;
      contentClockwise1Rect.bottom = 0;
      contentClockwise3Rect.top = 0;
      contentClockwise3Rect.bottom = viewportHeight - offsetY;
      contentRect.left = 0;
    }

    if (directionWithAlign.indexOf('left') !== -1) {
      contentContainerRect.left = 0;
      contentContainerRect.right = viewportWidth - offsetX;
      contentClockwise2Rect.left = offsetX;
      contentClockwise2Rect.right = 0;
      contentClockwise1Rect.top = 0;
      contentClockwise1Rect.bottom = viewportHeight - offsetY;
      contentClockwise3Rect.top = offsetY;
      contentClockwise3Rect.bottom = 0;
      contentRect.right = 0;
    }

    return {
      contentContainerRect: contentContainerRect,
      contentRect: contentRect,
      contentClockwise1Rect: contentClockwise1Rect,
      contentClockwise2Rect: contentClockwise2Rect,
      contentClockwise3Rect: contentClockwise3Rect
    };
  };

  _proto.getFullScreenPatch = function getFullScreenPatch() {
    var _this2 = this;

    var _this$props2 = this.props,
        cancelable = _this$props2.cancelable,
        backdropColor = _this$props2.backdropColor,
        fullScreenPatch = _this$props2.fullScreenPatch;

    if (fullScreenPatch.length !== 3) {
      throw new TypeError("fullScreenPatch \u53C2\u6570 " + fullScreenPatch + " \u4E3A\u65E0\u6548\u503C");
    }

    var rects = this.getRects();
    var tmp = fullScreenPatch.map(function (patchItem, patchIndex) {
      if (patchItem) {
        return "contentClockwise" + (patchIndex + 1) + "Rect";
      } else {
        return '';
      }
    }).filter(function (tmpItem) {
      return tmpItem;
    }).map(function (key) {
      return {
        key: key,
        cancelable: cancelable,
        closeFn: _this2.close.bind(_this2, 'backdrop'),
        rect: _objectSpread({}, rects[key], {
          backgroundColor: backdropColor
        })
      };
    });
    return tmp;
  };

  _proto.getContent = function getContent(inner) {
    var _this3 = this;

    var tmp = inner == null ? this.props.children : inner;

    var _this$getRects = this.getRects(),
        contentContainerRect = _this$getRects.contentContainerRect,
        contentRect = _this$getRects.contentRect;

    var fullScreenPatch = this.getFullScreenPatch();
    return React.createElement(View, {
      style: [{
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        // viewportWidth
        bottom: 0 // viewportHeight

      }, this.props.styles.root],
      collapsable: false,
      pointerEvents: "box-none"
    }, fullScreenPatch.map(function (patchItem, patchIndex) {
      return React.createElement(TouchableOpacity, {
        key: patchIndex,
        activeOpacity: 1,
        style: _objectSpread({
          position: 'absolute'
        }, patchItem.rect),
        onPress: function onPress() {
          if (patchItem.cancelable) {
            patchItem.closeFn();
          }
        }
      });
    }), React.createElement(View, {
      collapsable: false,
      style: [slideModalStyles.container, _objectSpread({}, contentContainerRect), this.props.styles.container]
    }, React.createElement(TouchableOpacity, {
      testID: "backdrop",
      style: [slideModalStyles.backdrop, {
        backgroundColor: this.props.backdropColor
      }, this.props.styles.backdrop],
      activeOpacity: 1,
      onPress: function onPress() {
        _this3.handlePressBackdrop();
      }
    }), React.createElement(Animated.View, {
      style: [slideModalStyles.content, _objectSpread({}, contentRect), {
        transform: [{
          translateY: this.animated.getState().translateY
        }, {
          translateX: this.animated.getState().translateX
        }],
        opacity: this.animated.getState().opacity
      }, this.props.styles.content],
      onLayout: this.handleLayout
    }, tmp || null)));
  };

  return SlideModal;
}(Modal);
SlideModal.defaultProps = _objectSpread({}, Modal.defaultProps, {
  styles: {},
  cancelable: false,
  offsetX: 0,
  offsetY: undefined,
  direction: 'up',
  align: 'right',
  fullScreenPatch: [false, false, false]
});